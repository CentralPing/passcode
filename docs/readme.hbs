# @CentralPing/passcode

[![Build Status](https://travis-ci.org/CentralPing/passcode.svg?branch=master)](https://travis-ci.org/CentralPing/passcode)
[![Coverage Status](https://coveralls.io/repos/github/CentralPing/passcode/badge.svg)](https://coveralls.io/github/CentralPing/passcode)
[![Dependency Status](https://david-dm.org/CentralPing/passcode.svg)](https://david-dm.org/CentralPing/passcode)
[![Greenkeeper Status](https://badges.greenkeeper.io/CentralPing/passcode.svg)](https://greenkeeper.io/)
[![Known Vulnerabilities](https://snyk.io/test/github/centralping/passcode/badge.svg)](https://snyk.io/test/github/centralping/passcode)

A slightly opinionated stateless passcode manager.

As with all JWTs, extreme care should be employed if including any sensitive information in the payload.

## Installation

`npm i --save https://github.com/CentralPing/passcode`

## API Reference

{{#module name="passcode"~}}
{{>body~}}
{{>members~}}
{{/module}}

## Examples

### For Simple Verification
**Warning: The following example results in an unsigned JWT with an unhashed code. It is highly advised to use both.**

*While all JWTs can be viewed by anyone, unsigned JWTs can also be **modified** by anyone. Seriously, don't use unsigned tokens with unhashed codes.*

```js
const {issue, verify} = require('passcode');

// Generate an unsigned token with random passcode
const {error, value: {id, expires, code, token}} = issue();
/**
 * Do something with the token
 */
// Verify token with code
const {error, value} = verify(token, {code});
```

### For Slighlty More Secure Simple Verification
By default the JWT is unsigned. Providing a secret (as well as other verification claims such as `iss`, `aud`, and `sub`) can provide a bit more security.

*Note: Signed JWTs are not **encrypted**. Any information in a signed JWT can still be viewed by anyone. Signed JWTs only prevent *modification* of the JWT.*

```js
const {issue, verify} = require('passcode');

// Generate a signed token with random passcode
const {error, value: {id, expires, code, token}} = issue({}, {YOUR_SECRET});
/**
 * Do something with the token
 */
// Verify token with code
const {error, value} = verify(token, {YOUR_SECRET, code});
```
### For Even Slighlty More Secure Simple Verification
By default challenge codes are stored as a plain string in the payload of the JWT. Providing a salt (as well as other hashing options) can provide a bit more security.

**It is highly recommended to use both a secret and a salt to issue and verify passcodes.**

```js
const {issue, verify} = require('passcode');

// Generate a signed token with random passcode
const {error, value: {id, expires, code, token}} = issue(
  {},
  {YOUR_SECRET},
  {YOUR_SALT}
);
/**
 * Do something with the token
 */
// Verify token with code
const {error, value} = verify(token, {YOUR_SECRET, code}, {YOUR_SALT});
```

### For Including Payload Data

```js
const {issue, verify} = require('passcode');

// Generate a signed token with custom payload
const {error, value: {id, expires, code, token}} = issue(
  {email: 'foo@bar.com'},
  {YOUR_SECRET},
  {YOUR_SALT}
);
/**
 * Do something with the token
 */
// Verify token with code
const {error, {email}} = verify(token, {YOUR_SECRET, code}, {YOUR_SALT});
```

## License

MIT
